package provider

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bytebase/terraform-provider-bytebase/api"
	"github.com/bytebase/terraform-provider-bytebase/provider/internal"

	v1pb "github.com/bytebase/bytebase/proto/generated-go/v1"
)

func dataSourceProject() *schema.Resource {
	return &schema.Resource{
		Description:        "The project data source.",
		ReadWithoutTimeout: dataSourceProjectRead,
		Schema: map[string]*schema.Schema{
			"resource_id": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: internal.ResourceIDValidation,
				Description:  "The project unique resource id.",
			},
			"title": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project title.",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project full name in projects/{resource id} format.",
			},
			"allow_modify_statement": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Allow modifying statement after issue is created.",
			},
			"auto_resolve_issue": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Enable auto resolve issue.",
			},
			"enforce_issue_title": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Enforce issue title created by user instead of generated by Bytebase.",
			},
			"auto_enable_backup": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to automatically enable backup.",
			},
			"skip_backup_errors": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to skip backup errors and continue the data migration.",
			},
			"postgres_database_tenant_mode": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to enable the database tenant mode for PostgreSQL. If enabled, the issue will be created with the pre-appended \"set role <db_owner>\" statement.",
			},
			"databases": getDatabasesSchema(true),
		},
	}
}

func getDatabasesSchema(computed bool) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Computed:    computed,
		Optional:    !computed,
		Description: "The databases full name in the resource.",
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
	}
}

func dataSourceProjectRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(api.Client)
	projectName := fmt.Sprintf("%s%s", internal.ProjectNamePrefix, d.Get("resource_id").(string))
	project, err := c.GetProject(ctx, projectName)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(project.Name)
	return setProject(ctx, c, d, project)
}

func flattenDatabaseList(databases []*v1pb.Database) []interface{} {
	dbList := []interface{}{}
	for _, database := range databases {
		dbList = append(dbList, database.Name)
	}
	return dbList
}

func setProject(
	ctx context.Context,
	client api.Client,
	d *schema.ResourceData,
	project *v1pb.Project,
) diag.Diagnostics {
	tflog.Debug(ctx, "[read project] start reading project", map[string]interface{}{
		"project": project.Name,
	})

	databases, err := client.ListDatabase(ctx, project.Name, &api.DatabaseFilter{}, true)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(project.Name)

	projectID, err := internal.GetProjectID(project.Name)
	if err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("resource_id", projectID); err != nil {
		return diag.Errorf("cannot set resource_id for project: %s", err.Error())
	}
	if err := d.Set("title", project.Title); err != nil {
		return diag.Errorf("cannot set title for project: %s", err.Error())
	}
	if err := d.Set("name", project.Name); err != nil {
		return diag.Errorf("cannot set name for project: %s", err.Error())
	}
	if err := d.Set("title", project.Title); err != nil {
		return diag.Errorf("cannot set title for project: %s", err.Error())
	}
	if err := d.Set("allow_modify_statement", project.AllowModifyStatement); err != nil {
		return diag.Errorf("cannot set allow_modify_statement for project: %s", err.Error())
	}
	if err := d.Set("auto_resolve_issue", project.AutoResolveIssue); err != nil {
		return diag.Errorf("cannot set auto_resolve_issue for project: %s", err.Error())
	}
	if err := d.Set("enforce_issue_title", project.EnforceIssueTitle); err != nil {
		return diag.Errorf("cannot set enforce_issue_title for project: %s", err.Error())
	}
	if err := d.Set("auto_enable_backup", project.AutoEnableBackup); err != nil {
		return diag.Errorf("cannot set auto_enable_backup for project: %s", err.Error())
	}
	if err := d.Set("skip_backup_errors", project.SkipBackupErrors); err != nil {
		return diag.Errorf("cannot set skip_backup_errors for project: %s", err.Error())
	}
	if err := d.Set("postgres_database_tenant_mode", project.PostgresDatabaseTenantMode); err != nil {
		return diag.Errorf("cannot set postgres_database_tenant_mode for project: %s", err.Error())
	}

	startTime := time.Now()
	databaseList := flattenDatabaseList(databases)
	if err := d.Set("databases", databaseList); err != nil {
		return diag.Errorf("cannot set databases for project: %s", err.Error())
	}
	tflog.Debug(ctx, "[read project] set project databases", map[string]interface{}{
		"project":   project.Name,
		"databases": len(databases),
		"ms":        time.Since(startTime).Milliseconds(),
	})

	return nil
}
