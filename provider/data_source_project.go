package provider

import (
	"bytes"
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/pkg/errors"

	"github.com/bytebase/terraform-provider-bytebase/api"
	"github.com/bytebase/terraform-provider-bytebase/provider/internal"

	v1pb "github.com/bytebase/bytebase/proto/generated-go/v1"
)

func dataSourceProject() *schema.Resource {
	return &schema.Resource{
		Description: "The project data source.",
		ReadContext: dataSourceProjectRead,
		Schema: map[string]*schema.Schema{
			"resource_id": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: internal.ResourceIDValidation,
				Description:  "The project unique resource id.",
			},
			"title": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project title.",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project full name in projects/{resource id} format.",
			},
			"key": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project key.",
			},
			"workflow": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project workflow.",
			},
			"allow_modify_statement": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Allow modifying statement after issue is created.",
			},
			"auto_resolve_issue": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Enable auto resolve issue.",
			},
			"enforce_issue_title": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Enforce issue title created by user instead of generated by Bytebase.",
			},
			"auto_enable_backup": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to automatically enable backup.",
			},
			"skip_backup_errors": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to skip backup errors and continue the data migration.",
			},
			"postgres_database_tenant_mode": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to enable the database tenant mode for PostgreSQL. If enabled, the issue will be created with the pre-appended \"set role <db_owner>\" statement.",
			},
			"databases": getProjectDatabasesSchema(true),
			"members":   getProjectMembersSchema(true),
		},
	}
}

func getProjectDatabasesSchema(computed bool) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeList,
		Computed:    computed,
		Optional:    !computed,
		Description: "The databases in the project.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"name": {
					Type:        schema.TypeString,
					Computed:    computed,
					Optional:    !computed,
					Description: "The database full name in instances/{instance id}/databases/{db name} format.",
				},
				"environment": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The database environment.",
				},
				"sync_state": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The existence of a database on latest sync.",
				},
				"successful_sync_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The latest synchronization time.",
				},
				"schema_version": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The version of database schema.",
				},
				"labels": {
					Type:        schema.TypeMap,
					Computed:    computed,
					Optional:    !computed,
					Description: "The deployment and policy control labels.",
					Elem:        &schema.Schema{Type: schema.TypeString},
				},
			},
		},
	}
}

func getProjectMembersSchema(computed bool) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Computed:    computed,
		Optional:    !computed,
		Description: "The members in the project.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"member": {
					Type:        schema.TypeString,
					Computed:    computed,
					Optional:    !computed,
					Description: "The member in user:{email} or group:{email} format.",
				},
				"role": {
					Type:        schema.TypeString,
					Computed:    computed,
					Optional:    !computed,
					Description: "The role full name in roles/{id} format.",
				},
				"condition": {
					Type:        schema.TypeSet,
					Computed:    computed,
					Optional:    true,
					Description: "Match the condition limit.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"database": {
								Type:        schema.TypeString,
								Computed:    computed,
								Optional:    true,
								Description: "The accessible database full name in instances/{instance resource id}/databases/{database name} format",
							},
							"schema": {
								Type:        schema.TypeString,
								Computed:    computed,
								Optional:    true,
								Description: "The accessible schema in the database",
							},
							"tables": {
								Type:     schema.TypeSet,
								Computed: computed,
								Optional: true,
								Elem: &schema.Schema{
									Type: schema.TypeString,
								},
								Set:         schema.HashString,
								Description: "The accessible table list",
							},
							"row_limit": {
								Type:        schema.TypeInt,
								Computed:    computed,
								Optional:    true,
								Description: "The export row limit for exporter role",
							},
							"expire_timestamp": {
								Type:        schema.TypeString,
								Computed:    computed,
								Optional:    true,
								Description: "The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format",
							},
						},
					},
					Set: func(i interface{}) int {
						return internal.ToHashcodeInt(conditionHash(i))
					},
				},
			},
		},
		Set: memberHash,
	}
}

func dataSourceProjectRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(api.Client)
	projectName := fmt.Sprintf("%s%s", internal.ProjectNamePrefix, d.Get("resource_id").(string))
	project, err := c.GetProject(ctx, projectName)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(project.Name)
	return setProject(ctx, c, d, project)
}

func flattenDatabaseList(databases []*v1pb.Database) []interface{} {
	dbList := []interface{}{}
	for _, database := range databases {
		db := map[string]interface{}{}
		db["name"] = database.Name
		db["environment"] = database.Environment
		db["sync_state"] = database.SyncState.String()
		db["successful_sync_time"] = database.SuccessfulSyncTime.AsTime().UTC().Format(time.RFC3339)
		db["schema_version"] = database.SchemaVersion
		db["labels"] = database.Labels
		dbList = append(dbList, db)
	}
	return dbList
}

func flattenMemberList(iamPolicy *v1pb.IamPolicy) ([]interface{}, error) {
	memberList := []interface{}{}
	for _, binding := range iamPolicy.Bindings {
		rawCondition := map[string]interface{}{}
		if condition := binding.Condition; condition != nil && condition.Expression != "" {
			expressions := strings.Split(condition.Expression, " && ")
			for _, expression := range expressions {
				if strings.HasPrefix(expression, `resource.database == "`) {
					rawCondition["database"] = strings.TrimSuffix(
						strings.TrimPrefix(expression, `resource.database == "`),
						`"`,
					)
				}
				if strings.HasPrefix(expression, `resource.schema == "`) {
					rawCondition["schema"] = strings.TrimSuffix(
						strings.TrimPrefix(expression, `resource.schema == "`),
						`"`,
					)
				}
				if strings.HasPrefix(expression, `resource.table in [`) {
					tableStr := strings.TrimSuffix(
						strings.TrimPrefix(expression, `resource.table in [`),
						`]`,
					)
					rawTableList := []string{}
					for _, t := range strings.Split(tableStr, ",") {
						rawTableList = append(rawTableList, strings.TrimSuffix(
							strings.TrimPrefix(t, `"`),
							`"`,
						))
					}
					rawCondition["tables"] = rawTableList
				}
				if strings.HasPrefix(expression, `request.row_limit <= `) {
					i, err := strconv.Atoi(strings.TrimPrefix(expression, `request.row_limit <= `))
					if err != nil {
						return nil, errors.Errorf("cannot convert %s to int with error: %s", expression, err.Error())
					}
					rawCondition["row_limit"] = i
				}
				if strings.HasPrefix(expression, "request.time < ") {
					rawCondition["expire_timestamp"] = strings.TrimSuffix(
						strings.TrimPrefix(expression, `request.time < timestamp("`),
						`")`,
					)
				}
			}
		}
		for _, member := range binding.Members {
			rawMember := map[string]interface{}{}
			rawMember["member"] = member
			rawMember["role"] = binding.Role
			rawMember["condition"] = schema.NewSet(func(i interface{}) int {
				return internal.ToHashcodeInt(conditionHash(i))
			}, []interface{}{rawCondition})
			memberList = append(memberList, rawMember)
		}
	}
	return memberList, nil
}

func setProject(
	ctx context.Context,
	client api.Client,
	d *schema.ResourceData,
	project *v1pb.Project,
) diag.Diagnostics {
	filter := fmt.Sprintf(`project == "%s"`, project.Name)
	listDBResponse, err := client.ListDatabase(ctx, "-", filter)
	if err != nil {
		return diag.FromErr(err)
	}

	iamPolicy, err := client.GetProjectIAMPolicy(ctx, project.Name)
	if err != nil {
		return diag.Errorf("failed to get project iam with error: %v", err)
	}

	d.SetId(project.Name)

	projectID, err := internal.GetProjectID(project.Name)
	if err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("resource_id", projectID); err != nil {
		return diag.Errorf("cannot set resource_id for project: %s", err.Error())
	}
	if err := d.Set("title", project.Title); err != nil {
		return diag.Errorf("cannot set title for project: %s", err.Error())
	}
	if err := d.Set("name", project.Name); err != nil {
		return diag.Errorf("cannot set name for project: %s", err.Error())
	}
	if err := d.Set("key", project.Key); err != nil {
		return diag.Errorf("cannot set key for project: %s", err.Error())
	}
	if err := d.Set("title", project.Title); err != nil {
		return diag.Errorf("cannot set title for project: %s", err.Error())
	}
	if err := d.Set("workflow", project.Workflow.String()); err != nil {
		return diag.Errorf("cannot set workflow for project: %s", err.Error())
	}
	if err := d.Set("allow_modify_statement", project.AllowModifyStatement); err != nil {
		return diag.Errorf("cannot set allow_modify_statement for project: %s", err.Error())
	}
	if err := d.Set("auto_resolve_issue", project.AutoResolveIssue); err != nil {
		return diag.Errorf("cannot set auto_resolve_issue for project: %s", err.Error())
	}
	if err := d.Set("enforce_issue_title", project.EnforceIssueTitle); err != nil {
		return diag.Errorf("cannot set enforce_issue_title for project: %s", err.Error())
	}
	if err := d.Set("auto_enable_backup", project.AutoEnableBackup); err != nil {
		return diag.Errorf("cannot set auto_enable_backup for project: %s", err.Error())
	}
	if err := d.Set("skip_backup_errors", project.SkipBackupErrors); err != nil {
		return diag.Errorf("cannot set skip_backup_errors for project: %s", err.Error())
	}
	if err := d.Set("postgres_database_tenant_mode", project.PostgresDatabaseTenantMode); err != nil {
		return diag.Errorf("cannot set postgres_database_tenant_mode for project: %s", err.Error())
	}

	if err := d.Set("databases", flattenDatabaseList(listDBResponse.Databases)); err != nil {
		return diag.Errorf("cannot set databases for project: %s", err.Error())
	}

	memberList, err := flattenMemberList(iamPolicy)
	if err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("members", schema.NewSet(memberHash, memberList)); err != nil {
		return diag.Errorf("cannot set members for project: %s", err.Error())
	}

	return nil
}

func memberHash(rawMember interface{}) int {
	var buf bytes.Buffer
	member := rawMember.(map[string]interface{})

	if v, ok := member["member"].(string); ok {
		_, _ = buf.WriteString(fmt.Sprintf("%s-", v))
	}
	if v, ok := member["role"].(string); ok {
		_, _ = buf.WriteString(fmt.Sprintf("%s-", v))
	}

	if condition, ok := member["condition"].(*schema.Set); ok && condition.Len() > 0 && condition.List()[0] != nil {
		rawCondition := condition.List()[0].(map[string]interface{})
		_, _ = buf.WriteString(conditionHash(rawCondition))
	}

	return internal.ToHashcodeInt(buf.String())
}

func conditionHash(rawCondition interface{}) string {
	var buf bytes.Buffer
	condition := rawCondition.(map[string]interface{})

	if v, ok := condition["database"].(string); ok {
		_, _ = buf.WriteString(fmt.Sprintf("%s-", v))
	}
	if v, ok := condition["schema"].(string); ok {
		_, _ = buf.WriteString(fmt.Sprintf("%s-", v))
	}
	if v, ok := condition["tables"].(*schema.Set); ok {
		for _, t := range v.List() {
			_, _ = buf.WriteString(fmt.Sprintf("table.%s-", t.(string)))
		}
	}
	if v, ok := condition["row_limit"].(int); ok {
		_, _ = buf.WriteString(fmt.Sprintf("%d-", v))
	}
	if v, ok := condition["expire_timestamp"].(string); ok {
		_, _ = buf.WriteString(fmt.Sprintf("%s-", v))
	}

	return buf.String()
}
