package provider

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bytebase/terraform-provider-bytebase/api"
	"github.com/bytebase/terraform-provider-bytebase/provider/internal"

	v1pb "buf.build/gen/go/bytebase/bytebase/protocolbuffers/go/v1"
)

func dataSourceProject() *schema.Resource {
	return &schema.Resource{
		Description:        "The project data source.",
		ReadWithoutTimeout: dataSourceProjectRead,
		Schema: map[string]*schema.Schema{
			"resource_id": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: internal.ResourceIDValidation,
				Description:  "The project unique resource id.",
			},
			"title": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project title.",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The project full name in projects/{resource id} format.",
			},
			"allow_modify_statement": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Allow modifying statement after issue is created.",
			},
			"auto_resolve_issue": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Enable auto resolve issue.",
			},
			"enforce_issue_title": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Enforce issue title created by user instead of generated by Bytebase.",
			},
			"auto_enable_backup": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to automatically enable backup.",
			},
			"skip_backup_errors": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to skip backup errors and continue the data migration.",
			},
			"allow_self_approval": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to allow the issue creator to self-approve the issue.",
			},
			"postgres_database_tenant_mode": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether to enable the database tenant mode for PostgreSQL. If enabled, the issue will be created with the pre-appended \"set role <db_owner>\" statement.",
			},
			"databases": getDatabasesSchema(true),
			"webhooks":  getWebhooksSchema(true),
		},
	}
}

func getWebhooksSchema(computed bool) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Optional:    !computed,
		Computed:    computed,
		Description: "The webhooks in the project.",
		MinItems:    0,
		ConfigMode:  schema.SchemaConfigModeAttr,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"type": {
					Type:        schema.TypeString,
					Required:    true,
					Description: "The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.",
					ValidateFunc: validation.StringInSlice([]string{
						v1pb.Webhook_SLACK.String(),
						v1pb.Webhook_DISCORD.String(),
						v1pb.Webhook_TEAMS.String(),
						v1pb.Webhook_DINGTALK.String(),
						v1pb.Webhook_FEISHU.String(),
						v1pb.Webhook_WECOM.String(),
						v1pb.Webhook_LARK.String(),
					}, false),
				},
				"title": {
					Type:         schema.TypeString,
					Required:     true,
					Description:  "The webhook title",
					ValidateFunc: validation.StringIsNotEmpty,
				},
				"name": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The webhook full name in projects/{resource id}/webhooks/{id} format.",
				},
				"url": {
					Type:         schema.TypeString,
					Required:     true,
					Description:  "The webhook URL",
					ValidateFunc: validation.IsURLWithHTTPorHTTPS,
				},
				"direct_message": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.",
				},
				"notification_types": {
					Type:        schema.TypeSet,
					Required:    true,
					MinItems:    1,
					Description: "notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.",
					Elem: &schema.Schema{
						Type:        schema.TypeString,
						Description: "Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L486 for support types.",
						ValidateFunc: validation.StringInSlice([]string{
							v1pb.Activity_NOTIFY_ISSUE_APPROVED.String(),
							v1pb.Activity_NOTIFY_PIPELINE_ROLLOUT.String(),
							v1pb.Activity_ISSUE_CREATE.String(),
							v1pb.Activity_ISSUE_COMMENT_CREATE.String(),
							v1pb.Activity_ISSUE_FIELD_UPDATE.String(),
							v1pb.Activity_ISSUE_STATUS_UPDATE.String(),
							v1pb.Activity_ISSUE_APPROVAL_NOTIFY.String(),
							v1pb.Activity_ISSUE_PIPELINE_STAGE_STATUS_UPDATE.String(),
							v1pb.Activity_ISSUE_PIPELINE_TASK_RUN_STATUS_UPDATE.String(),
						}, false),
					},
				},
			},
		},
		Set: webhookHash,
	}
}

func getDatabasesSchema(computed bool) *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Computed:    computed,
		Optional:    !computed,
		Description: "The databases full name in the resource.",
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
	}
}

func dataSourceProjectRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(api.Client)
	projectName := fmt.Sprintf("%s%s", internal.ProjectNamePrefix, d.Get("resource_id").(string))
	project, err := c.GetProject(ctx, projectName)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(project.Name)
	return setProject(ctx, c, d, project)
}

func flattenDatabaseList(databases []*v1pb.Database) []interface{} {
	dbList := []interface{}{}
	for _, database := range databases {
		dbList = append(dbList, database.Name)
	}
	return dbList
}

func flattenWebhookList(webhooks []*v1pb.Webhook) []interface{} {
	rawWebhooks := []interface{}{}
	for _, webhook := range webhooks {
		rawWebhook := make(map[string]interface{})
		rawWebhook["title"] = webhook.Title
		rawWebhook["type"] = webhook.Type.String()
		rawWebhook["url"] = webhook.Url
		// Include name for reference but it shouldn't affect the hash
		rawWebhook["name"] = webhook.Name
		rawWebhook["direct_message"] = webhook.DirectMessage

		// Convert notification types to interface slice, then wrap in Set
		notificationTypes := []interface{}{}
		for _, notificationType := range webhook.NotificationTypes {
			notificationTypes = append(notificationTypes, notificationType.String())
		}
		// Use schema.NewSet for consistency with the schema definition
		rawWebhook["notification_types"] = schema.NewSet(schema.HashString, notificationTypes)

		rawWebhooks = append(rawWebhooks, rawWebhook)
	}
	return rawWebhooks
}

func setProject(
	ctx context.Context,
	client api.Client,
	d *schema.ResourceData,
	project *v1pb.Project,
) diag.Diagnostics {
	tflog.Debug(ctx, "[read project] start reading project", map[string]interface{}{
		"project": project.Name,
	})

	databases, err := client.ListDatabase(ctx, project.Name, &api.DatabaseFilter{}, true)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(project.Name)

	projectID, err := internal.GetProjectID(project.Name)
	if err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("resource_id", projectID); err != nil {
		return diag.Errorf("cannot set resource_id for project: %s", err.Error())
	}
	if err := d.Set("title", project.Title); err != nil {
		return diag.Errorf("cannot set title for project: %s", err.Error())
	}
	if err := d.Set("name", project.Name); err != nil {
		return diag.Errorf("cannot set name for project: %s", err.Error())
	}
	if err := d.Set("title", project.Title); err != nil {
		return diag.Errorf("cannot set title for project: %s", err.Error())
	}
	if err := d.Set("allow_modify_statement", project.AllowModifyStatement); err != nil {
		return diag.Errorf("cannot set allow_modify_statement for project: %s", err.Error())
	}
	if err := d.Set("auto_resolve_issue", project.AutoResolveIssue); err != nil {
		return diag.Errorf("cannot set auto_resolve_issue for project: %s", err.Error())
	}
	if err := d.Set("enforce_issue_title", project.EnforceIssueTitle); err != nil {
		return diag.Errorf("cannot set enforce_issue_title for project: %s", err.Error())
	}
	if err := d.Set("auto_enable_backup", project.AutoEnableBackup); err != nil {
		return diag.Errorf("cannot set auto_enable_backup for project: %s", err.Error())
	}
	if err := d.Set("skip_backup_errors", project.SkipBackupErrors); err != nil {
		return diag.Errorf("cannot set skip_backup_errors for project: %s", err.Error())
	}
	if err := d.Set("allow_self_approval", project.AllowSelfApproval); err != nil {
		return diag.Errorf("cannot set allow_self_approval for project: %s", err.Error())
	}
	if err := d.Set("postgres_database_tenant_mode", project.PostgresDatabaseTenantMode); err != nil {
		return diag.Errorf("cannot set postgres_database_tenant_mode for project: %s", err.Error())
	}

	startTime := time.Now()
	databaseList := flattenDatabaseList(databases)
	if err := d.Set("databases", databaseList); err != nil {
		return diag.Errorf("cannot set databases for project: %s", err.Error())
	}
	tflog.Debug(ctx, "[read project] set project databases", map[string]interface{}{
		"project":   project.Name,
		"databases": len(databases),
		"ms":        time.Since(startTime).Milliseconds(),
	})

	if err := d.Set("webhooks", schema.NewSet(webhookHash, flattenWebhookList(project.Webhooks))); err != nil {
		return diag.Errorf("cannot set webhooks for project: %s", err.Error())
	}

	return nil
}

func webhookHash(rawSchema interface{}) int {
	webhook := convertToV1Webhook(rawSchema)
	return internal.ToHash(webhook)
}
